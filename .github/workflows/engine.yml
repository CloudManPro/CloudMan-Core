# Arquivo: .github/workflows/engine.yml (no reposit√≥rio cloudman-core)
name: Dynamic GitOps Engine (Multi-Cloud)

on:
  # Permite ser chamado pelos reposit√≥rios dos clientes
  workflow_call:
    inputs:
      # Mantemos apenas inputs gen√©ricos opcionais, pois o manifesto dita as regras
      default_region:
        required: false
        type: string
        default: "us-east-1"
        description: "Regi√£o fallback caso n√£o esteja no manifesto"

  # Gatilhos manuais/diretos para testes
  workflow_dispatch:
  push:
    paths:
      - '**/manifest.json'
      - '**/main.tf'

permissions:
  id-token: write   # CR√çTICO: Necess√°rio para gerar tokens OIDC para AWS/GCP
  contents: read    # Necess√°rio para ler o c√≥digo

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout do C√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üõ†Ô∏è Configurar Terraform
        uses: hashicorp/setup-terraform@v3

      - name: üöÄ Executar Pipeline Din√¢mico (Multi-Cloud)
        shell: bash
        env:
          # Vari√°veis necess√°rias para a troca manual de token OIDC
          ACTIONS_ID_TOKEN_REQUEST_TOKEN: ${{ secrets.GITHUB_TOKEN }} # (Injetado automaticamente pelo runner, mas refor√ßamos o uso)
          DEFAULT_REGION: ${{ inputs.default_region || 'us-east-1' }}
        run: |
          # ==============================================================================
          # FUN√á√ÉO AUXILIAR: Obter Token OIDC do GitHub
          # ==============================================================================
          get_oidc_token() {
            # Solicita o JWT ao provedor OIDC interno do GitHub Actions
            # Audience 'sts.amazonaws.com' √© padr√£o para AWS
            local aud="sts.amazonaws.com"
            local token_url="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${aud}"
            
            response=$(curl -s -H "Authorization: bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" "$token_url")
            echo $response | jq -r '.value'
          }

          # ==============================================================================
          # 1. DETEC√á√ÉO DO MANIFESTO
          # ==============================================================================
          echo "üîç Buscando manifest.json..."
          
          # Tenta achar no diff ou fallback para busca no diret√≥rio
          MANIFEST_PATH=$(git diff --name-only HEAD^ HEAD | grep "manifest.json" | head -n 1)
          if [ -z "$MANIFEST_PATH" ]; then
            MANIFEST_PATH=$(find . -name "manifest.json" -not -path "*/.*" | head -n 1)
          fi

          if [ -z "$MANIFEST_PATH" ]; then
            echo "‚ùå Erro: Nenhum manifest.json encontrado."
            exit 1
          fi
          echo "‚úÖ Manifesto carregado: $MANIFEST_PATH"

          # ==============================================================================
          # 2. PARSE E EXECU√á√ÉO
          # ==============================================================================
          
          # Extrai a a√ß√£o global (plan/apply/destroy)
          ACTION=$(jq -r '.action' "$MANIFEST_PATH")
          echo "‚ö° Modo de Execu√ß√£o: $ACTION"

          # L√™ a lista de estados (pastas) a processar
          # Nota: O jq -c garante que cada objeto venha em uma linha para o loop
          STATES=$(jq -c '.states[]' "$MANIFEST_PATH")

          # Loop por cada item/pasta definido no manifesto
          echo "$STATES" | while read -r stage; do
            
            # Extrai dados do est√°gio atual
            PATH_DIR=$(echo "$stage" | jq -r '.path')
            CLOUD_ID=$(echo "$stage" | jq -r '.cloud')
            
            echo "::group::üìÇ Processando: $PATH_DIR (Cloud Ref: $CLOUD_ID)"
            
            if [ ! -d "$PATH_DIR" ]; then
               echo "‚ö†Ô∏è  Aviso: Diret√≥rio $PATH_DIR n√£o existe. Pulando."
               echo "::endgroup::"
               continue
            fi

            # Busca a configura√ß√£o da nuvem correspondente no array 'clouds'
            # Isso faz o "JOIN" entre o state e a configura√ß√£o da conta
            CLOUD_CONFIG=$(jq -c ".clouds[] | select(.id == \"$CLOUD_ID\")" "$MANIFEST_PATH")
            
            if [ -z "$CLOUD_CONFIG" ]; then
              echo "‚ùå Erro: Configura√ß√£o de nuvem '$CLOUD_ID' n√£o encontrada no manifesto."
              exit 1
            fi

            CLOUD_TYPE=$(echo "$CLOUD_CONFIG" | jq -r '.type')
            IDENTIFIER=$(echo "$CLOUD_CONFIG" | jq -r '.identifier') # Ex: ARN da Role
            REGION=$(echo "$CLOUD_CONFIG" | jq -r '.region // env.DEFAULT_REGION')

            # --- L√ìGICA DE LOGIN MULTI-CLOUD ---
            echo "üîë Autenticando em: $CLOUD_TYPE ($IDENTIFIER) na regi√£o $REGION"

            # Limpa credenciais anteriores para garantir isolamento
            unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AWS_REGION

            case $CLOUD_TYPE in
              aws)
                # 1. Pega o token OIDC do GitHub
                JWT_TOKEN=$(get_oidc_token)
                
                if [ "$JWT_TOKEN" == "null" ] || [ -z "$JWT_TOKEN" ]; then
                   echo "‚ùå Falha ao obter token OIDC do GitHub."
                   exit 1
                fi

                # 2. Assume a Role na AWS via CLI (usando o token)
                CREDS_JSON=$(aws sts assume-role-with-web-identity \
                  --role-arn "$IDENTIFIER" \
                  --role-session-name "CloudManSession-$GITHUB_RUN_ID" \
                  --web-identity-token "$JWT_TOKEN" \
                  --duration-seconds 900 \
                  --output json)

                if [ $? -ne 0 ]; then
                   echo "‚ùå Falha ao assumir role AWS ($IDENTIFIER)."
                   exit 1
                fi

                # 3. Exporta as credenciais para a sess√£o atual do Shell
                export AWS_ACCESS_KEY_ID=$(echo $CREDS_JSON | jq -r '.Credentials.AccessKeyId')
                export AWS_SECRET_ACCESS_KEY=$(echo $CREDS_JSON | jq -r '.Credentials.SecretAccessKey')
                export AWS_SESSION_TOKEN=$(echo $CREDS_JSON | jq -r '.Credentials.SessionToken')
                export AWS_REGION="$REGION"
                ;;

              # Futuros providers (GCP, Azure) entrariam aqui...
              *)
                echo "‚ùå Provider '$CLOUD_TYPE' n√£o suportado ainda."
                exit 1
                ;;
            esac

            # --- EXECU√á√ÉO DO TERRAFORM ---
            echo "üèóÔ∏è  Executando Terraform $ACTION..."
            
            (
              cd "$PATH_DIR"
              
              # Init: Reconfigura o backend (S3) usando as credenciais que acabamos de assumir
              # Assumimos que o bucket do backend est√° na mesma conta da Role assumida
              terraform init -reconfigure -input=false
              
              if [ "$ACTION" == "plan" ]; then
                terraform plan -input=false
              elif [ "$ACTION" == "apply" ]; then
                terraform apply -auto-approve -input=false
              elif [ "$ACTION" == "destroy" ]; then
                terraform destroy -auto-approve -input=false
              fi
            )
            
            EXIT_CODE=$?
            if [ $EXIT_CODE -ne 0 ]; then
               echo "‚ùå Falha na execu√ß√£o do Terraform em $PATH_DIR"
               exit $EXIT_CODE
            fi

            echo "::endgroup::"
          done

          echo "‚úÖ Pipeline Multi-Cloud finalizado com sucesso."
