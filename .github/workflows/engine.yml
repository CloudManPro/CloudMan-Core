name: Dynamic GitOps Engine (Full)

on:
  workflow_call:
    inputs:
      default_region:
        required: false
        type: string
        default: "us-east-1"
  workflow_dispatch:
  push:
    paths:
      - '**/manifest.json'
      - '**/main.tf'

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      # 1. Checkout do C√≥digo do Cliente
      - name: üì• Checkout Client Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      # 2. Checkout do Engine (Para carregar os scripts .sh)
      - name: üì• Checkout CloudMan Engine
        uses: actions/checkout@v4
        with:
          repository: CloudManPro/cloudman-core
          path: .cloudman-engine
          ref: main

      - name: üõ†Ô∏è Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: üöÄ Executar Pipeline Modular
        shell: bash
        env:
          GH_CLONE_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          LOGIN_REGION: ${{ inputs.default_region || 'us-east-1' }}
          # M√ÅGICA: Passamos todos os secrets como JSON para permitir busca din√¢mica
          SECRETS_CONTEXT: ${{ toJSON(secrets) }}
        run: |
          # ==============================================================================
          # CONFIGURA√á√ïES E CORES
          # ==============================================================================
          set -o pipefail
          BLUE='\033[0;34m'
          CYAN='\033[0;36m'
          GREEN='\033[0;32m'
          YELLOW='\033[0;33m'
          RED='\033[0;31m'
          NC='\033[0m'

          # Configura caminhos dos scripts modulares
          ENGINE_PATH=$(readlink -f .cloudman-engine)
          AUTH_SCRIPTS="$ENGINE_PATH/scripts/auth"
          
          if [ ! -d "$AUTH_SCRIPTS" ]; then
              echo "‚ùå Erro Cr√≠tico: Pasta scripts/auth n√£o encontrada em $ENGINE_PATH"
              echo "Certifique-se de que os arquivos .sh foram commitados no repo cloudman-core."
              exit 1
          fi
          
          chmod +x $AUTH_SCRIPTS/*.sh

          # Carrega fun√ß√µes utilit√°rias e AWS (Backend sempre precisa de AWS)
          source "$AUTH_SCRIPTS/aws.sh"

          # ==============================================================================
          # FUN√á√ÉO PRINCIPAL: Execu√ß√£o do Terraform
          # ==============================================================================
          run_terraform_process() {
              local path=$1
              local action=$2
              local auth_json=$3
              local provider=$4
              local label="[$path]"
              
              local color=$BLUE
              if [ "$provider" == "azure" ]; then color=$CYAN; fi
              if [ "$provider" == "cloudflare" ]; then color=$GREEN; fi
              if [ "$provider" == "google" ]; then color=$YELLOW; fi
              if [ "$provider" == "oci" ]; then color=$RED; fi

              # Cria subshell para isolar vari√°veis de ambiente
              (
                  cd "$path"

                  # ---------------------------------------------------------
                  # PASSO 1: TERRAFORM INIT (Usando Credenciais de BACKEND)
                  # ---------------------------------------------------------
                  # Aqui garantimos que o Terraform use o profile 'backend' configurado
                  # no in√≠cio do script para acessar o S3/DynamoDB, sem interfer√™ncia
                  # das credenciais do Target (que ainda n√£o foram carregadas).
                  
                  echo -e "${color}‚ñ∂Ô∏è ${label} Inicializando Backend (State)...${NC}"
                  
                  # Remove vars de ambiente que possam conflitar
                  unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AWS_REGION
                  
                  # For√ßa o uso do profile configurado via 'aws configure --profile backend'
                  export AWS_PROFILE=backend
                  
                  terraform init -reconfigure -input=false
                  
                  # Remove o profile para n√£o for√ßar o backend durante o apply
                  unset AWS_PROFILE

                  # ---------------------------------------------------------
                  # PASSO 2: PREPARA√á√ÉO DO TARGET (Autentica√ß√£o do Provider)
                  # ---------------------------------------------------------
                  
                  # Caso especial: Cloudflare (Secrets Din√¢micos)
                  if [ "$provider" == "cloudflare" ]; then
                      local acc_id=$(echo "$auth_json" | jq -r '.account_id')
                      local secret_key="AUTH_CLOUDFLARE_${acc_id}"
                      local token=$(echo "$SECRETS_CONTEXT" | jq -r --arg key "$secret_key" '.[$key]')
                      
                      if [ "$token" == "null" ] || [ -z "$token" ]; then
                          echo "‚ùå Erro: Secret '$secret_key' n√£o encontrado para a conta $acc_id."
                          exit 1
                      fi
                      export CLOUDFLARE_API_TOKEN="$token"
                  fi
                  
                  # Autentica√ß√£o Padr√£o via Script (AWS, Azure, OCI, etc)
                  local script_file="$AUTH_SCRIPTS/${provider}.sh"
                  
                  if [ -f "$script_file" ]; then
                      # Carrega e executa a fun√ß√£o espec√≠fica do provedor
                      # Isso vai EXPORTAR as vari√°veis (ex: AWS_ACCESS_KEY_ID) do TARGET
                      source "$script_file"
                      "auth_${provider}" "$auth_json" "target"
                  else
                      if [ "$provider" != "cloudflare" ]; then
                           echo "‚ö†Ô∏è  Aviso: Script de autentica√ß√£o para '$provider' n√£o encontrado. Tentando execu√ß√£o direta."
                      fi
                  fi

                  # ---------------------------------------------------------
                  # PASSO 3: EXECU√á√ÉO DO TERRAFORM (Plan/Apply)
                  # ---------------------------------------------------------
                  echo -e "${color}‚ñ∂Ô∏è ${label} Executando Terraform $action...${NC}"

                  if [ "$action" == "plan" ]; then
                    terraform plan -input=false
                  elif [ "$action" == "apply" ]; then
                    terraform apply -auto-approve -input=false
                  elif [ "$action" == "destroy" ]; then
                    terraform destroy -auto-approve -input=false
                  fi
              )

              return $?
          }

          # ==============================================================================
          # MAIN: L√ìGICA PRINCIPAL (LEITURA DO MANIFESTO)
          # ==============================================================================
          
          echo "üîç Buscando manifest.json..."
          MANIFEST_PATH=$(git diff --name-only HEAD^ HEAD | grep "manifest.json" | head -n 1)
          if [ -z "$MANIFEST_PATH" ]; then
            MANIFEST_PATH=$(find . -name "manifest.json" -not -path "*/.*" | head -n 1)
          fi
          if [ -z "$MANIFEST_PATH" ]; then
            echo "‚ùå Erro: Nenhum manifest.json encontrado."
            exit 1
          fi
          echo "‚úÖ Manifesto carregado: $MANIFEST_PATH"

          ACTION=$(jq -r '.action // "apply"' "$MANIFEST_PATH")
          BACKEND_ROLE=$(jq -r '.backend_global_config.role_arn' "$MANIFEST_PATH")
          BACKEND_REGION=$(jq -r '.backend_global_config.region' "$MANIFEST_PATH")

          echo "‚ö° A√ß√£o Global: $ACTION"
          echo "üîë Configurando Backend Profile (AWS S3/DynamoDB)..."
          
          # Chama a fun√ß√£o auth_aws importada de aws.sh para o Backend
          # Isso cria o profile 'backend' no arquivo ~/.aws/credentials
          auth_aws "{\"role_arn\": \"$BACKEND_ROLE\", \"region\": \"$BACKEND_REGION\"}" "backend"

          # ---------------------------------------------------------
          # DEPEND√äNCIAS EXTERNAS (Sparse Checkout)
          # ---------------------------------------------------------
          EXTERNAL_REPOS=$(jq -c '.external_repositories // []' "$MANIFEST_PATH")
          
          if [ "$EXTERNAL_REPOS" != "[]" ] && [ "$EXTERNAL_REPOS" != "null" ]; then
              echo "üì¶ Analisando depend√™ncias externas..."
              
              echo "$EXTERNAL_REPOS" | jq -c '.[]' | while read -r repo; do
                  REPO_NAME=$(echo "$repo" | jq -r '.repo_name')
                  ORG=$(echo "$repo" | jq -r '.org')
                  BRANCH=$(echo "$repo" | jq -r '.branch')
                  TARGET_DIR=$(echo "$repo" | jq -r '.target_dir')
                  FOLDERS=$(echo "$repo" | jq -r '.folders | join(" ")')
                  
                  FULL_TARGET_DIR="./$TARGET_DIR"
                  REPO_URL="https://x-access-token:${GH_CLONE_TOKEN}@github.com/${ORG}/${REPO_NAME}.git"
                  
                  if [ ! -d "$FULL_TARGET_DIR" ]; then
                      echo "‚¨áÔ∏è  Iniciando Sparse-Checkout de $ORG/$REPO_NAME ($BRANCH)..."
                      git clone --depth 1 -b "$BRANCH" --filter=blob:none --no-checkout "$REPO_URL" "$FULL_TARGET_DIR"
                      cd "$FULL_TARGET_DIR"
                      git sparse-checkout init --cone
                      git sparse-checkout set $FOLDERS
                      git checkout "$BRANCH"
                      cd - > /dev/null
                  else
                      echo "üîÑ Atualizando pastas em $REPO_NAME..."
                      (cd "$FULL_TARGET_DIR" && git sparse-checkout set $FOLDERS && git pull origin "$BRANCH")
                  fi
              done
          fi

          # ---------------------------------------------------------
          # EXECU√á√ÉO DOS EST√ÅGIOS
          # ---------------------------------------------------------
          TOTAL_STAGES=$(jq '.pipeline_stages | length' "$MANIFEST_PATH")

          for (( i=0; i<$TOTAL_STAGES; i++ )); do
              STAGE_NAME=$(jq -r ".pipeline_stages[$i].stage_name" "$MANIFEST_PATH")
              IS_PARALLEL=$(jq -r ".pipeline_stages[$i].parallel_execution" "$MANIFEST_PATH")
              STATES_JSON=$(jq -c ".pipeline_stages[$i].states[]" "$MANIFEST_PATH")

              echo "::group::üöÄ Est√°gio: $STAGE_NAME (Paralelo: $IS_PARALLEL)"

              pids=""
              failed=0

              while read -r state; do
                  path=$(echo "$state" | jq -r '.path')
                  provider=$(echo "$state" | jq -r '.provider')
                  target_auth=$(echo "$state" | jq -c '.target_auth') # jq -c para manter JSON
                  
                  if [ ! -d "$path" ]; then
                       echo "‚ö†Ô∏è  Diret√≥rio $path n√£o existe. Pulando."
                       continue
                  fi

                  # Link para m√≥dulos externos se existirem
                  if [ -d ".external_modules" ]; then
                      ABS_EXT_MOD=$(readlink -f .external_modules)
                      ln -sfn "$ABS_EXT_MOD" "$path/.external_modules"
                  fi

                  if [ "$IS_PARALLEL" == "true" ]; then
                      run_terraform_process "$path" "$ACTION" "$target_auth" "$provider" &
                      pids="$pids $!"
                  else
                      run_terraform_process "$path" "$ACTION" "$target_auth" "$provider"
                      if [ $? -ne 0 ]; then failed=1; break; fi
                  fi
              done <<< "$STATES_JSON"

              if [ "$IS_PARALLEL" == "true" ]; then
                  for pid in $pids; do
                      wait $pid
                      if [ $? -ne 0 ]; then failed=1; fi
                  done
              fi

              if [ $failed -ne 0 ]; then
                  echo "::error::Falha na execu√ß√£o do est√°gio $STAGE_NAME"
                  exit 1
              fi

              echo "::endgroup::"
          done

          echo "‚úÖ Pipeline finalizado com sucesso."
