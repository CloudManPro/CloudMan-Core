name: Dynamic GitOps Engine (Full)

on:
  workflow_call:
    inputs:
      default_region:
        required: false
        type: string
        default: "us-east-1"
  workflow_dispatch:
  push:
    paths:
      - '**/manifest.json'
      - '**/main.tf'

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: ðŸ› ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: ðŸš€ Executar Pipeline HÃ­brido
        shell: bash
        env:
          # REMOVIDO: ACTIONS_ID_TOKEN_REQUEST_TOKEN (O GitHub jÃ¡ provÃª internamente para OIDC)
          # ADICIONADO: VariÃ¡vel especÃ­fica para o Clone
          GH_CLONE_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          LOGIN_REGION: ${{ inputs.default_region || 'us-east-1' }}
        run: |

          # ==============================================================================
          # CONFIGURAÃ‡Ã•ES E CORES
          # ==============================================================================
          set -o pipefail
          BLUE='\033[0;34m'
          CYAN='\033[0;36m'
          GREEN='\033[0;32m'
          RED='\033[0;31m'
          NC='\033[0m'

          # ==============================================================================
          # FUNÃ‡ÃƒO 1: Obter Token OIDC (Herdado do seu cÃ³digo antigo)
          # ==============================================================================
          get_oidc_token() {
            local aud="sts.amazonaws.com"
            local token_url="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${aud}"
            response=$(curl -s -H "Authorization: bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" "$token_url")
            echo $response | jq -r '.value'
          }

          # ==============================================================================
          # FUNÃ‡ÃƒO 2: AutenticaÃ§Ã£o DinÃ¢mica (Backend Profile vs Target Env)
          # ==============================================================================
          authenticate() {
            local role_arn=$1
            local region=$2
            local type=$3 # "backend" ou "target"
            local session_name="CloudMan-${type}"

            # 1. Pega Token GitHub
            local jwt=$(get_oidc_token)
            if [ "$jwt" == "null" ] || [ -z "$jwt" ]; then
                echo "âŒ Erro ao obter OIDC Token."
                return 1
            fi

            # 2. Assume Role na AWS
            local creds=$(aws sts assume-role-with-web-identity \
              --role-arn "$role_arn" \
              --role-session-name "$session_name" \
              --web-identity-token "$jwt" \
              --duration-seconds 900 \
              --region "$region" \
              --output json)

            if [ $? -ne 0 ]; then
               echo "âŒ Erro ao assumir role $role_arn"
               return 1
            fi

            local key_id=$(echo $creds | jq -r '.Credentials.AccessKeyId')
            local secret=$(echo $creds | jq -r '.Credentials.SecretAccessKey')
            local token=$(echo $creds | jq -r '.Credentials.SessionToken')

            if [ "$type" == "backend" ]; then
                # Salva no profile para o Terraform Backend S3 usar
                aws configure set aws_access_key_id "$key_id" --profile backend
                aws configure set aws_secret_access_key "$secret" --profile backend
                aws configure set aws_session_token "$token" --profile backend
                aws configure set region "$region" --profile backend
            else
                # Exporta como Env Var para o Provider AWS usar
                export AWS_ACCESS_KEY_ID="$key_id"
                export AWS_SECRET_ACCESS_KEY="$secret"
                export AWS_SESSION_TOKEN="$token"
                export AWS_REGION="$region"
            fi
          }

          # ==============================================================================
          # FUNÃ‡ÃƒO 3: ExecuÃ§Ã£o do Terraform (Suporta Logs com Tag)
          # ==============================================================================
          run_terraform_process() {
              local path=$1
              local action=$2
              local auth_json=$3
              local provider=$4
              local label="[$path]"
              
              # Cor diferente para Azure (visual)
              local color=$BLUE
              if [ "$provider" == "azure" ]; then color=$CYAN; fi

              # Cria subshell para isolar variÃ¡veis de ambiente do Target
              (
                  # 1. Autentica no Target (dentro do subshell)
                  if [ "$provider" == "aws" ]; then
                      local t_role=$(echo "$auth_json" | jq -r '.role_arn')
                      local t_region=$(echo "$auth_json" | jq -r '.region')
                      authenticate "$t_role" "$t_region" "target"
                  elif [ "$provider" == "azure" ]; then
                      # LÃ³gica Azure aqui (export ARM_...)
                      :
                  fi

                  echo -e "${color}â–¶ï¸ ${label} Iniciando Terraform $action...${NC}"

                  cd "$path"
                  
                  # 2. Executa Terraform
                  # O profile 'backend' jÃ¡ foi configurado globalmente antes
                  terraform init -reconfigure -input=false

                  if [ "$action" == "plan" ]; then
                    terraform plan -input=false
                  elif [ "$action" == "apply" ]; then
                    terraform apply -auto-approve -input=false
                  if [ "$action" == "destroy" ]; then
                    terraform destroy -auto-approve -input=false
                  fi
              )

              # Retorna o exit code do pipeline (graÃ§as ao set -o pipefail)
              return $?
          }

          # ==============================================================================
          # MAIN: LÃ“GICA PRINCIPAL
          # ==============================================================================
          
          # 1. DetecÃ§Ã£o do Manifesto (Do seu cÃ³digo antigo)
          echo "ðŸ” Buscando manifest.json..."
          MANIFEST_PATH=$(git diff --name-only HEAD^ HEAD | grep "manifest.json" | head -n 1)
          if [ -z "$MANIFEST_PATH" ]; then
            MANIFEST_PATH=$(find . -name "manifest.json" -not -path "*/.*" | head -n 1)
          fi
          if [ -z "$MANIFEST_PATH" ]; then
            echo "âŒ Erro: Nenhum manifest.json encontrado."
            exit 1
          fi
          echo "âœ… Manifesto carregado: $MANIFEST_PATH"

          # 2. ConfiguraÃ§Ãµes Globais
          ACTION=$(jq -r '.action // "apply"' "$MANIFEST_PATH") # Default apply se vazio
          BACKEND_ROLE=$(jq -r '.backend_global_config.role_arn' "$MANIFEST_PATH")
          BACKEND_REGION=$(jq -r '.backend_global_config.region' "$MANIFEST_PATH")

          echo "âš¡ AÃ§Ã£o Global: $ACTION"
          echo "ðŸ”‘ Configurando Backend Profile ($BACKEND_ROLE)..."
          authenticate "$BACKEND_ROLE" "$BACKEND_REGION" "backend"

          # ==============================================================================
          # NOVO: CLONE DE DEPENDÃŠNCIAS EXTERNAS (Repo Source-First)
          # ==============================================================================
          EXTERNAL_REPOS=$(jq -c '.external_repositories // []' "$MANIFEST_PATH")
          
          if [ "$EXTERNAL_REPOS" != "[]" ] && [ "$EXTERNAL_REPOS" != "null" ]; then
              echo "ðŸ“¦ Analisando dependÃªncias externas..."
              
              echo "$EXTERNAL_REPOS" | jq -c '.[]' | while read -r repo; do
                  REPO_NAME=$(echo "$repo" | jq -r '.repo_name')
                  ORG=$(echo "$repo" | jq -r '.org')
                  BRANCH=$(echo "$repo" | jq -r '.branch')
                  TARGET_DIR=$(echo "$repo" | jq -r '.target_dir')
                  FOLDERS=$(echo "$repo" | jq -r '.folders | join(" ")')
                  
                  FULL_TARGET_DIR="./$TARGET_DIR"
                  REPO_URL="https://x-access-token:${GH_CLONE_TOKEN}@github.com/${ORG}/${REPO_NAME}.git"
                  
                  if [ ! -d "$FULL_TARGET_DIR" ]; then
                      echo "â¬‡ï¸  Iniciando Sparse-Checkout de $ORG/$REPO_NAME ($BRANCH)..."
                      
                      # Clone parcial (apenas metadados)
                      git clone --depth 1 -b "$BRANCH" --filter=blob:none --no-checkout "$REPO_URL" "$FULL_TARGET_DIR"
                      
                      cd "$FULL_TARGET_DIR"
                      git sparse-checkout init --cone
                      git sparse-checkout set $FOLDERS
                      git checkout "$BRANCH"
                      cd - > /dev/null
                  else
                      echo "ðŸ”„ Atualizando pastas em $REPO_NAME..."
                      (cd "$FULL_TARGET_DIR" && git sparse-checkout set $FOLDERS && git pull origin "$BRANCH")
                  fi
              done
          fi



          # 3. Loop pelos EstÃ¡gios
          TOTAL_STAGES=$(jq '.pipeline_stages | length' "$MANIFEST_PATH")


          for (( i=0; i<$TOTAL_STAGES; i++ )); do
              STAGE_NAME=$(jq -r ".pipeline_stages[$i].stage_name" "$MANIFEST_PATH")
              IS_PARALLEL=$(jq -r ".pipeline_stages[$i].parallel_execution" "$MANIFEST_PATH")
              STATES_JSON=$(jq -c ".pipeline_stages[$i].states[]" "$MANIFEST_PATH")

              echo "::group::ðŸš€ EstÃ¡gio: $STAGE_NAME (Paralelo: $IS_PARALLEL)"

              pids=""
              failed=0

              while read -r state; do
                  path=$(echo "$state" | jq -r '.path')
                  provider=$(echo "$state" | jq -r '.provider')
                  target_auth=$(echo "$state" | jq -r '.target_auth')
                  
                  if [ ! -d "$path" ]; then
                       echo "âš ï¸  DiretÃ³rio $path nÃ£o existe. Pulando."
                       continue
                  fi

                  # [NOVO] CRIA SYMLINK PARA MÃ“DULOS EXTERNOS
                  # O Terraform espera achar .external_modules dentro de $path
                  # O Clone baixou em ./.external_modules (raiz)
                  if [ -d ".external_modules" ]; then
                      ABS_EXT_MOD=$(readlink -f .external_modules)
                      # Cria link simbÃ³lico (-s) forÃ§ado (-f) e sem dereferenciar destino se for link (-n)
                      ln -sfn "$ABS_EXT_MOD" "$path/.external_modules"
                  fi

                  if [ "$IS_PARALLEL" == "true" ]; then
                      # Roda em background
                      run_terraform_process "$path" "$ACTION" "$target_auth" "$provider" &
                      pids="$pids $!"
                  else
                      # Roda sequencial
                      run_terraform_process "$path" "$ACTION" "$target_auth" "$provider"
                      if [ $? -ne 0 ]; then failed=1; break; fi
                  fi
              done <<< "$STATES_JSON"


              # Se paralelo, aguarda todos
              if [ "$IS_PARALLEL" == "true" ]; then
                  for pid in $pids; do
                      wait $pid
                      if [ $? -ne 0 ]; then failed=1; fi
                  done
              fi

              if [ $failed -ne 0 ]; then
                  echo "::error::Falha na execuÃ§Ã£o do estÃ¡gio $STAGE_NAME"
                  exit 1
              fi

              echo "::endgroup::"
          done

          echo "âœ… Pipeline finalizado com sucesso."
