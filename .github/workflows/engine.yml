name: Dynamic GitOps Engine (Full)

on:
  workflow_call:
    inputs:
      default_region:
        required: false
        type: string
        default: "us-east-1"
  workflow_dispatch:
  push:
    paths:
      - '**/manifest.json'
      - '**/main.tf'

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout Client Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      # INICIO DA MODIFICA√á√ÉO
      - name: üßê Analyze Manifest Requirements
        id: manifest_check
        shell: bash
        run: |
          # Encontra o manifesto
          MANIFEST_PATH=$(find . -name "manifest.json" -not -path "*/.*" | head -n 1)
          
          if [ -z "$MANIFEST_PATH" ]; then
            echo "‚ö†Ô∏è Nenhum manifesto encontrado."
            echo "needs_private_access=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # L√≥gica: Se external_repositories for um array E tiver tamanho > 0, precisamos do token
          NEEDS_ACCESS=$(jq -r 'if (.external_repositories | type == "array") and (.external_repositories | length > 0) then "true" else "false" end' "$MANIFEST_PATH")
          
          echo "üìä Status dos reposit√≥rios externos: $NEEDS_ACCESS"
          echo "needs_private_access=$NEEDS_ACCESS" >> $GITHUB_OUTPUT

      - name: üîë CloudMan Auth Bridge
        id: gatekeeper
        # S√≥ executa se o passo anterior detectou reposit√≥rios externos
        if: steps.manifest_check.outputs.needs_private_access == 'true'
        run: |
          echo "üîÑ Iniciando troca de token OIDC..."
          ID_TOKEN=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL&aud=https://github.com/cloudmandev" | jq -r '.value')
          
          RESPONSE=$(curl -s -X POST https://dev.callback.cloudman.pro/cb/CallBack-dev \
            -d "{\"action\": \"exchange_oidc_for_token\", \"params\": {\"oidc_token\": \"$ID_TOKEN\", \"github_repo\": \"CloudManPro/cloudman-core\"}}")
          
          TOKEN=$(echo $RESPONSE | jq -r .token)
          
          if [ "$TOKEN" == "null" ] || [ -z "$TOKEN" ]; then
            echo "‚ùå Falha na autentica√ß√£o: $RESPONSE"
            exit 1
          fi

          echo "token=$TOKEN" >> $GITHUB_OUTPUT

      - name: üì• Checkout CloudMan Engine
        uses: actions/checkout@v4
        with:
          repository: CloudManPro/cloudman-core
          path: .cloudman-engine
          ref: main
          # L√ìGICA CR√çTICA:
          # Se o gatekeeper rodou, usa o token dele.
          # Se pulou, usa o GITHUB_TOKEN padr√£o (funciona se a Engine for p√∫blica ou interna √† org)
          token: ${{ steps.gatekeeper.outputs.token || secrets.GITHUB_TOKEN }}

      - name: üõ†Ô∏è Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: üöÄ Executar Pipeline Modular
        shell: bash
        env:
          # Mesma l√≥gica de fallback aqui para o clone dentro do script
          GH_CLONE_TOKEN: ${{ steps.gatekeeper.outputs.token || secrets.GITHUB_TOKEN }}
          LOGIN_REGION: ${{ inputs.default_region || 'us-east-1' }}
          SECRETS_CONTEXT: ${{ toJSON(secrets) }}
        run: |
          # ==============================================================================
          # CONFIGURA√á√ïES E CORES
          # ==============================================================================
          set -o pipefail
          BLUE='\033[0;34m'
          CYAN='\033[0;36m'
          GREEN='\033[0;32m'
          YELLOW='\033[0;33m'
          RED='\033[0;31m'
          NC='\033[0m'

          ENGINE_PATH=$(readlink -f .cloudman-engine)
          AUTH_SCRIPTS="$ENGINE_PATH/scripts/auth"
          
          if [ ! -d "$AUTH_SCRIPTS" ]; then
              echo "‚ùå Erro Cr√≠tico: Pasta scripts/auth n√£o encontrada"
              exit 1
          fi
          
          chmod +x $AUTH_SCRIPTS/*.sh
          source "$AUTH_SCRIPTS/aws.sh"

          # ==============================================================================
          # FUN√á√ÉO DE LOG DE DEBUG
          # ==============================================================================
          debug_auth_status() {
              local context=$1
              echo "üîé [DEBUG] Verificando identidade ($context):"
              if [ -n "$AWS_PROFILE" ]; then echo "   - AWS_PROFILE: $AWS_PROFILE"; else echo "   - AWS_PROFILE: (unset)"; fi
              if [ -n "$AWS_REGION" ]; then echo "   - AWS_REGION: $AWS_REGION"; else echo "   - AWS_REGION: (unset)"; fi
              
              # Verifica identidade real (se tiver credenciais carregadas)
              aws sts get-caller-identity --query "Arn" --output text 2>/dev/null || echo "   - (Sem credenciais ativas no terminal)"
              echo "---------------------------------------------------"
          }

          # ==============================================================================
          # FUN√á√ÉO PRINCIPAL: Execu√ß√£o do Terraform
          # ==============================================================================
          run_terraform_process() {
              local path=$1
              local action=$2
              local auth_json=$3
              local provider=$4
              local label="[$path]"
              
              local color=$BLUE
              if [ "$provider" == "azure" ]; then color=$CYAN; fi
              if [ "$provider" == "cloudflare" ]; then color=$GREEN; fi
              if [ "$provider" == "google" ]; then color=$YELLOW; fi
              if [ "$provider" == "oci" ]; then color=$RED; fi

              (
                  cd "$path"

                  # ---------------------------------------------------------
                  # PASSO 1: TERRAFORM INIT
                  # ---------------------------------------------------------
                  echo -e "${color}‚ñ∂Ô∏è ${label} Inicializando Backend (State)...${NC}"
                  
                  # Limpa ambiente para garantir que o Init use apenas o profile
                  unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AWS_REGION

                  # SOLU√á√ÉO DO PROBLEMA DE LOCK:
                  # Injetamos '-backend-config="profile=backend"'
                  # Isso for√ßa o Terraform a salvar no .terraform/terraform.tfstate que
                  # ele DEVE usar o profile 'backend' para opera√ß√µes de estado (S3/Dynamo),
                  # ignorando as vari√°veis de ambiente que vamos carregar no passo 2.
                  
                  terraform init -reconfigure -input=false \
                      -backend-config="profile=backend" \
                      -backend-config="region=$BACKEND_REGION"

                  # ---------------------------------------------------------
                  # PASSO 2: PREPARA√á√ÉO DO TARGET
                  # ---------------------------------------------------------
                  
                  # Cloudflare handling
                  if [ "$provider" == "cloudflare" ]; then
                      # Prioriza o secret_name vindo do manifest, se n√£o existir, usa o fallback antigo
                      local secret_key=$(echo "$auth_json" | jq -r '.secret_name // empty')
                      
                      if [ -z "$secret_key" ]; then
                          local acc_id=$(echo "$auth_json" | jq -r '.account_id')
                          secret_key="AUTH_CLOUDFLARE_${acc_id}"
                      fi
                  
                      echo "üîë Buscando Secret: $secret_key"
                      local token=$(echo "$SECRETS_CONTEXT" | jq -r --arg key "$secret_key" '.[$key]')

                      if [ "$token" == "null" ] || [ -z "$token" ]; then
                          echo "‚ùå Erro: Secret '$secret_key' n√£o encontrado."
                          exit 1
                      fi
                      export CLOUDFLARE_API_TOKEN="$token"
                  fi
                  
                  local script_file="$AUTH_SCRIPTS/${provider}.sh"
                  
                  if [ -f "$script_file" ]; then
                      echo "üî∂ Autenticando $provider (target)..."
                      source "$script_file"
                      "auth_${provider}" "$auth_json" "target"
                      
                      # Debug: Mostra que agora estamos logados como TARGET
                      if [ "$provider" == "aws" ]; then
                          debug_auth_status "TARGET AUTH"
                      fi
                  else
                      if [ "$provider" != "cloudflare" ]; then
                           echo "‚ö†Ô∏è  Aviso: Script de autentica√ß√£o para '$provider' n√£o encontrado."
                      fi
                  fi

                  # ---------------------------------------------------------
                  # PASSO 3: EXECU√á√ÉO DO TERRAFORM
                  # ---------------------------------------------------------
                  echo -e "${color}‚ñ∂Ô∏è ${label} Executando Terraform $action...${NC}"

                  # Como configuramos o backend com profile=backend no init,
                  # o Terraform vai usar:
                  # 1. Profile 'backend' -> Para S3 e DynamoDB (Lock)
                  # 2. Env Vars (AWS_ACCESS_KEY...) -> Para o Provider AWS (Resources)
                  
                  if [ "$action" == "plan" ]; then
                    terraform plan -input=false
                  elif [ "$action" == "apply" ]; then
                    terraform apply -auto-approve -input=false
                  elif [ "$action" == "destroy" ]; then
                    terraform destroy -auto-approve -input=false
                  fi
              )

              return $?
          }

          # ==============================================================================
          # MAIN
          # ==============================================================================
          
          echo "üîç Buscando manifest.json..."
          MANIFEST_PATH=$(git diff --name-only HEAD^ HEAD | grep "manifest.json" | head -n 1)
          if [ -z "$MANIFEST_PATH" ]; then
            MANIFEST_PATH=$(find . -name "manifest.json" -not -path "*/.*" | head -n 1)
          fi
          if [ -z "$MANIFEST_PATH" ]; then
            echo "‚ùå Erro: Nenhum manifest.json encontrado."
            exit 1
          fi
          echo "‚úÖ Manifesto carregado: $MANIFEST_PATH"

          ACTION=$(jq -r '.action // "apply"' "$MANIFEST_PATH")
          
          # Exporta para ser vis√≠vel dentro do subshell do terraform init
          export BACKEND_ROLE=$(jq -r '.backend_global_config.role_arn' "$MANIFEST_PATH")
          export BACKEND_REGION=$(jq -r '.backend_global_config.region' "$MANIFEST_PATH")

          echo "‚ö° A√ß√£o Global: $ACTION"
          echo "üîë Configurando Backend Profile..."
          
          # Cria o profile [backend] em ~/.aws/credentials
          auth_aws "{\"role_arn\": \"$BACKEND_ROLE\", \"region\": \"$BACKEND_REGION\"}" "backend"
          debug_auth_status "BACKEND PROFILE CRIADO"

          # ---------------------------------------------------------
          # DEPEND√äNCIAS EXTERNAS
          # ---------------------------------------------------------
          EXTERNAL_REPOS=$(jq -c '.external_repositories // []' "$MANIFEST_PATH")
          if [ "$EXTERNAL_REPOS" != "[]" ] && [ "$EXTERNAL_REPOS" != "null" ]; then
              echo "üì¶ Analisando depend√™ncias externas..."
              echo "$EXTERNAL_REPOS" | jq -c '.[]' | while read -r repo; do
                  REPO_NAME=$(echo "$repo" | jq -r '.repo_name')
                  ORG=$(echo "$repo" | jq -r '.org')
                  BRANCH=$(echo "$repo" | jq -r '.branch')
                  TARGET_DIR=$(echo "$repo" | jq -r '.target_dir')
                  FOLDERS=$(echo "$repo" | jq -r '.folders | join(" ")')
                  FULL_TARGET_DIR="./$TARGET_DIR"
                  REPO_URL="https://x-access-token:${GH_CLONE_TOKEN}@github.com/${ORG}/${REPO_NAME}.git"
                  
                  if [ ! -d "$FULL_TARGET_DIR" ]; then
                      echo "‚¨áÔ∏è  Iniciando Sparse-Checkout de $ORG/$REPO_NAME..."
                      git clone --depth 1 -b "$BRANCH" --filter=blob:none --no-checkout "$REPO_URL" "$FULL_TARGET_DIR"
                      cd "$FULL_TARGET_DIR"
                      git sparse-checkout init --cone
                      git sparse-checkout set $FOLDERS
                      git checkout "$BRANCH"
                      cd - > /dev/null
                  else
                      echo "üîÑ Atualizando pastas em $REPO_NAME..."
                      (cd "$FULL_TARGET_DIR" && git sparse-checkout set $FOLDERS && git pull origin "$BRANCH")
                  fi
              done
          fi

          # ---------------------------------------------------------
          # EXECU√á√ÉO DOS EST√ÅGIOS
          # ---------------------------------------------------------
          TOTAL_STAGES=$(jq '.pipeline_stages | length' "$MANIFEST_PATH")

          for (( i=0; i<$TOTAL_STAGES; i++ )); do
              STAGE_NAME=$(jq -r ".pipeline_stages[$i].stage_name" "$MANIFEST_PATH")
              IS_PARALLEL=$(jq -r ".pipeline_stages[$i].parallel_execution" "$MANIFEST_PATH")
              STATES_JSON=$(jq -c ".pipeline_stages[$i].states[]" "$MANIFEST_PATH")

              echo "::group::üöÄ Est√°gio: $STAGE_NAME"

              pids=""
              failed=0

              while read -r state; do
                  path=$(echo "$state" | jq -r '.path')
                  provider=$(echo "$state" | jq -r '.provider')
                  target_auth=$(echo "$state" | jq -c '.target_auth')
                  
                  if [ ! -d "$path" ]; then
                       echo "‚ö†Ô∏è  Diret√≥rio $path n√£o existe. Pulando."
                       continue
                  fi
                  if [ -d ".external_modules" ]; then
                      ln -sfn "$(readlink -f .external_modules)" "$path/.external_modules"
                  fi

                  if [ "$IS_PARALLEL" == "true" ]; then
                      run_terraform_process "$path" "$ACTION" "$target_auth" "$provider" &
                      pids="$pids $!"
                  else
                      run_terraform_process "$path" "$ACTION" "$target_auth" "$provider"
                      if [ $? -ne 0 ]; then failed=1; break; fi
                  fi
              done <<< "$STATES_JSON"

              if [ "$IS_PARALLEL" == "true" ]; then
                  for pid in $pids; do
                      wait $pid
                      if [ $? -ne 0 ]; then failed=1; fi
                  done
              fi

              if [ $failed -ne 0 ]; then
                  echo "::error::Falha no est√°gio $STAGE_NAME"
                  exit 1
              fi
              echo "::endgroup::"
          done
          echo "‚úÖ Pipeline finalizado."
