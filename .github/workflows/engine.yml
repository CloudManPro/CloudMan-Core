# Arquivo: .github/workflows/engine.yml (no reposit√≥rio cloudman-core)
name: Dynamic GitOps Engine (Simplified)

on:
  # Permite ser chamado pelos reposit√≥rios dos clientes
  workflow_call:
    inputs:
      default_region:
        required: false
        type: string
        default: "us-east-1"
        description: "Regi√£o padr√£o para autentica√ß√£o AWS CLI"

  # Gatilhos para testes manuais
  workflow_dispatch:
  push:
    paths:
      - '**/manifest.json'
      - '**/main.tf'

permissions:
  id-token: write   # CR√çTICO: Necess√°rio para gerar tokens OIDC
  contents: read    # Necess√°rio para ler o c√≥digo

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout do C√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üõ†Ô∏è Configurar Terraform
        uses: hashicorp/setup-terraform@v3

      - name: üöÄ Executar Pipeline Din√¢mico
        shell: bash
        env:
          # Token injetado automaticamente pelo GitHub, necess√°rio para o OIDC manual
          ACTIONS_ID_TOKEN_REQUEST_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          LOGIN_REGION: ${{ inputs.default_region || 'us-east-1' }}
        run: |
          # ==============================================================================
          # FUN√á√ÉO AUXILIAR: Obter Token OIDC do GitHub
          # ==============================================================================
          get_oidc_token() {
            local aud="sts.amazonaws.com"
            local token_url="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${aud}"
            response=$(curl -s -H "Authorization: bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" "$token_url")
            echo $response | jq -r '.value'
          }

          # ==============================================================================
          # 1. DETEC√á√ÉO DO MANIFESTO
          # ==============================================================================
          echo "üîç Buscando manifest.json..."
          
          MANIFEST_PATH=$(git diff --name-only HEAD^ HEAD | grep "manifest.json" | head -n 1)
          if [ -z "$MANIFEST_PATH" ]; then
            MANIFEST_PATH=$(find . -name "manifest.json" -not -path "*/.*" | head -n 1)
          fi

          if [ -z "$MANIFEST_PATH" ]; then
            echo "‚ùå Erro: Nenhum manifest.json encontrado."
            exit 1
          fi
          echo "‚úÖ Manifesto carregado: $MANIFEST_PATH"

          # ==============================================================================
          # 2. LEITURA E EXECU√á√ÉO (Loop Simplificado)
          # ==============================================================================
          
          # Extrai a a√ß√£o global
          ACTION=$(jq -r '.action' "$MANIFEST_PATH")
          echo "‚ö° Modo de Execu√ß√£o: $ACTION"

          # L√™ a lista de estados (pastas)
          STATES=$(jq -c '.states[]' "$MANIFEST_PATH")

          # Loop por cada item do manifesto
          echo "$STATES" | while read -r stage; do
            
            # --- LEITURA DIRETA DOS DADOS (Novo Formato) ---
            PATH_DIR=$(echo "$stage" | jq -r '.path')
            CLOUD_TYPE=$(echo "$stage" | jq -r '.type')
            IDENTIFIER=$(echo "$stage" | jq -r '.identifier') # Ex: ARN da Role
            
            echo "::group::üìÇ Processando: $PATH_DIR"
            
            if [ ! -d "$PATH_DIR" ]; then
               echo "‚ö†Ô∏è  Aviso: Diret√≥rio $PATH_DIR n√£o existe. Pulando."
               echo "::endgroup::"
               continue
            fi

            # --- AUTENTICA√á√ÉO DIN√ÇMICA (Just-in-Time) ---
            echo "üîë Autenticando em: $CLOUD_TYPE ($IDENTIFIER)"

            # Limpa credenciais da itera√ß√£o anterior
            unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AWS_REGION

            case $CLOUD_TYPE in
              aws)
                # 1. Obter Token OIDC
                JWT_TOKEN=$(get_oidc_token)
                
                if [ "$JWT_TOKEN" == "null" ] || [ -z "$JWT_TOKEN" ]; then
                   echo "‚ùå Falha ao obter token OIDC."
                   exit 1
                fi

                # 2. Assumir Role na AWS
                # Usamos a regi√£o padr√£o apenas para conseguir conectar no STS
                CREDS_JSON=$(aws sts assume-role-with-web-identity \
                  --role-arn "$IDENTIFIER" \
                  --role-session-name "CloudManSession-$GITHUB_RUN_ID" \
                  --web-identity-token "$JWT_TOKEN" \
                  --duration-seconds 900 \
                  --region "$LOGIN_REGION" \
                  --output json)

                if [ $? -ne 0 ]; then
                   echo "‚ùå Falha ao assumir role ($IDENTIFIER)."
                   exit 1
                fi

                # 3. Exportar Credenciais
                export AWS_ACCESS_KEY_ID=$(echo $CREDS_JSON | jq -r '.Credentials.AccessKeyId')
                export AWS_SECRET_ACCESS_KEY=$(echo $CREDS_JSON | jq -r '.Credentials.SecretAccessKey')
                export AWS_SESSION_TOKEN=$(echo $CREDS_JSON | jq -r '.Credentials.SessionToken')
                
                # Regi√£o para a sess√£o (Terraform provider sobrescrever√° isso se necess√°rio)
                export AWS_REGION="$LOGIN_REGION"
                ;;

              *)
                echo "‚ùå Provider '$CLOUD_TYPE' n√£o suportado."
                exit 1
                ;;
            esac

            # --- EXECU√á√ÉO DO TERRAFORM ---
            echo "üèóÔ∏è  Executando Terraform $ACTION..."
            
            (
              cd "$PATH_DIR"
              
              # Init: Reconfigura o backend
              terraform init -reconfigure -input=false
              
              if [ "$ACTION" == "plan" ]; then
                terraform plan -input=false
              elif [ "$ACTION" == "apply" ]; then
                terraform apply -auto-approve -input=false
              elif [ "$ACTION" == "destroy" ]; then
                terraform destroy -auto-approve -input=false
              fi
            )
            
            EXIT_CODE=$?
            if [ $EXIT_CODE -ne 0 ]; then
               echo "‚ùå Falha na execu√ß√£o do Terraform em $PATH_DIR"
               exit $EXIT_CODE
            fi

            echo "::endgroup::"
          done

          echo "‚úÖ Pipeline finalizado com sucesso."
