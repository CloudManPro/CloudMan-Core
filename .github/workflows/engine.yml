#!/bin/bash

# Configura√ß√µes Visuais
BOLD='\033[1m'
BLUE='\033[0;34m'
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'
mkdir -p logs

# Vari√°veis Globais de Cache de Sess√£o (Para execu√ß√£o sequencial)
CURRENT_TARGET_ID=""
CURRENT_TARGET_REGION=""

# ==============================================================================
# FUN√á√ÉO: Autentica√ß√£o Inteligente (Com Cache)
# ==============================================================================
authenticate_target() {
    local provider=$1
    local auth_json=$2
    local is_parallel=$3 # Se for paralelo, FOR√áA re-autentica√ß√£o isolada

    # Se for paralelo, n√£o podemos usar cache global (vari√°veis de ambiente conflitariam)
    if [ "$is_parallel" == "true" ]; then
        # L√≥gica de auth isolada (subshell) j√° √© garantida pelo encapsulamento da fun√ß√£o run_terraform
        # Apenas executa o login normalmente
        : 
    else
        # Se for sequencial, tenta usar o cache
        if [ "$provider" == "aws" ]; then
            local role=$(echo "$auth_json" | jq -r '.role_arn')
            local region=$(echo "$auth_json" | jq -r '.region')
            
            # Check de Cache
            if [ "$role" == "$CURRENT_TARGET_ID" ] && [ "$region" == "$CURRENT_TARGET_REGION" ]; then
                echo "‚ö° [Auth] Reutilizando sess√£o AWS existente ($role)..."
                return
            fi

            echo "üîë [Auth] Iniciando nova sess√£o AWS na conta $role..."
            
            # Login AWS (Sem exportar para profile, usa env vars globais)
            # Nota: Em ambiente real, use aws-actions/configure-aws-credentials se poss√≠vel
            # Aqui simulamos com comando AWS CLI direto
            creds=$(aws sts assume-role --role-arn "$role" --role-session-name "EngineSession" --output json)
            export AWS_ACCESS_KEY_ID=$(echo $creds | jq -r .Credentials.AccessKeyId)
            export AWS_SECRET_ACCESS_KEY=$(echo $creds | jq -r .Credentials.SecretAccessKey)
            export AWS_SESSION_TOKEN=$(echo $creds | jq -r .Credentials.SessionToken)
            export AWS_REGION="$region"

            # Atualiza Cache
            CURRENT_TARGET_ID="$role"
            CURRENT_TARGET_REGION="$region"
        fi
    fi
}

# ==============================================================================
# FUN√á√ÉO: Executa Terraform (Isolado)
# ==============================================================================
run_terraform() {
    local path=$1
    local provider=$2
    local auth=$3
    local is_parallel=$4
    
    local log_file="logs/${path//\//_}.log" # Sanitiza nome do path
    local exit_file="logs/${path//\//_}.exit"

    (
        # Se for paralelo, precisa autenticar aqui dentro (subshell)
        if [ "$is_parallel" == "true" ]; then
            authenticate_target "$provider" "$auth" "true"
        fi

        echo "üöÄ Iniciando Terraform em $path..."
        cd "$path"
        terraform init -input=false > /dev/null
        terraform apply -auto-approve -input=false
    ) > "$log_file" 2>&1

    echo $? > "$exit_file"
}

# ==============================================================================
# LOOP PRINCIPAL
# ==============================================================================

# 1. Autentica√ß√£o Global no Backend (Sempre necess√°ria uma vez)
BACKEND_ROLE=$(jq -r '.backend_global_config.role_arn' manifest.json)
# ... Configura profile [backend] aqui ...

TOTAL_STAGES=$(jq '.pipeline_stages | length' manifest.json)

for (( i=0; i<$TOTAL_STAGES; i++ )); do
    STAGE_NAME=$(jq -r ".pipeline_stages[$i].stage_name" manifest.json)
    IS_PARALLEL=$(jq -r ".pipeline_stages[$i].parallel_execution" manifest.json)
    STATES_JSON=$(jq -c ".pipeline_stages[$i].states[]" manifest.json)

    echo "::group::üìÇ Est√°gio: $STAGE_NAME"

    # Arrays de controle para o Dashboard
    pids=""
    active_paths=""

    while read -r state; do
        path=$(echo "$state" | jq -r '.path')
        provider=$(echo "$state" | jq -r '.provider')
        auth=$(echo "$state" | jq -r '.target_auth')

        if [ "$IS_PARALLEL" == "true" ]; then
            # Modo Paralelo: Joga para background (&)
            # A auth acontece DENTRO da fun√ß√£o run_terraform para n√£o vazar
            run_terraform "$path" "$provider" "$auth" "true" &
            pids="$pids $!"
            active_paths="$active_paths $path"
        else
            # Modo Sequencial: Usa Auth Inteligente no escopo principal
            authenticate_target "$provider" "$auth" "false"
            
            # Roda bloqueante (sem &)
            # Pode redirecionar para arquivo e dar 'tail' para ver progresso
            run_terraform "$path" "$provider" "$auth" "false"
            
            # Mostra o log imediatamente ap√≥s acabar
            cat "logs/${path//\//_}.log"
        fi
    done <<< "$STATES_JSON"

    # DASHBOARD PARA PARALELISMO
    if [ "$IS_PARALLEL" == "true" ]; then
        echo -e "${BOLD}Aguardando processos paralelos...${NC}"
        wait $pids
        
        # Exibe logs finais organizados
        for p in $active_paths; do
            echo "üìÑ Log de: $p"
            cat "logs/${p//\//_}.log"
        done
    fi

    echo "::endgroup::"
done
