name: Dynamic GitOps Engine (Full)

on:
  workflow_call:
    inputs:
      default_region:
        required: false
        type: string
        default: "us-east-1"
  workflow_dispatch:
  push:
    paths:
      - '**/manifest.json'
      - '**/main.tf'

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üõ†Ô∏è Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: üöÄ Executar Pipeline H√≠brido
        shell: bash
        env:
          ACTIONS_ID_TOKEN_REQUEST_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          LOGIN_REGION: ${{ inputs.default_region || 'us-east-1' }}
        run: |
          # ==============================================================================
          # CONFIGURA√á√ïES E CORES
          # ==============================================================================
          set -o pipefail
          BLUE='\033[0;34m'
          CYAN='\033[0;36m'
          GREEN='\033[0;32m'
          RED='\033[0;31m'
          NC='\033[0m'

          # ==============================================================================
          # FUN√á√ÉO 1: Obter Token OIDC (Herdado do seu c√≥digo antigo)
          # ==============================================================================
          get_oidc_token() {
            local aud="sts.amazonaws.com"
            local token_url="${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${aud}"
            response=$(curl -s -H "Authorization: bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" "$token_url")
            echo $response | jq -r '.value'
          }

          # ==============================================================================
          # FUN√á√ÉO 2: Autentica√ß√£o Din√¢mica (Backend Profile vs Target Env)
          # ==============================================================================
          authenticate() {
            local role_arn=$1
            local region=$2
            local type=$3 # "backend" ou "target"
            local session_name="CloudMan-${type}"

            # 1. Pega Token GitHub
            local jwt=$(get_oidc_token)
            if [ "$jwt" == "null" ] || [ -z "$jwt" ]; then
                echo "‚ùå Erro ao obter OIDC Token."
                return 1
            fi

            # 2. Assume Role na AWS
            local creds=$(aws sts assume-role-with-web-identity \
              --role-arn "$role_arn" \
              --role-session-name "$session_name" \
              --web-identity-token "$jwt" \
              --duration-seconds 900 \
              --region "$region" \
              --output json)

            if [ $? -ne 0 ]; then
               echo "‚ùå Erro ao assumir role $role_arn"
               return 1
            fi

            local key_id=$(echo $creds | jq -r '.Credentials.AccessKeyId')
            local secret=$(echo $creds | jq -r '.Credentials.SecretAccessKey')
            local token=$(echo $creds | jq -r '.Credentials.SessionToken')

            if [ "$type" == "backend" ]; then
                # Salva no profile para o Terraform Backend S3 usar
                aws configure set aws_access_key_id "$key_id" --profile backend
                aws configure set aws_secret_access_key "$secret" --profile backend
                aws configure set aws_session_token "$token" --profile backend
                aws configure set region "$region" --profile backend
            else
                # Exporta como Env Var para o Provider AWS usar
                export AWS_ACCESS_KEY_ID="$key_id"
                export AWS_SECRET_ACCESS_KEY="$secret"
                export AWS_SESSION_TOKEN="$token"
                export AWS_REGION="$region"
            fi
          }

          # ==============================================================================
          # FUN√á√ÉO 3: Execu√ß√£o do Terraform (Suporta Logs com Tag)
          # ==============================================================================
          run_terraform_process() {
              local path=$1
              local action=$2
              local auth_json=$3
              local provider=$4
              local label="[$path]"
              
              # Cor diferente para Azure (visual)
              local color=$BLUE
              if [ "$provider" == "azure" ]; then color=$CYAN; fi

              # Cria subshell para isolar vari√°veis de ambiente do Target
              (
                  # 1. Autentica no Target (dentro do subshell)
                  if [ "$provider" == "aws" ]; then
                      local t_role=$(echo "$auth_json" | jq -r '.role_arn')
                      local t_region=$(echo "$auth_json" | jq -r '.region')
                      authenticate "$t_role" "$t_region" "target"
                  elif [ "$provider" == "azure" ]; then
                      # L√≥gica Azure aqui (export ARM_...)
                      :
                  fi

                  echo -e "${color}‚ñ∂Ô∏è ${label} Iniciando Terraform $action...${NC}"

                  cd "$path"
                  
                  # 2. Executa Terraform
                  # O profile 'backend' j√° foi configurado globalmente antes
                  terraform init -reconfigure -input=false

                  if [ "$action" == "plan" ]; then
                    terraform plan -input=false
                  elif [ "$action" == "apply" ]; then
                    terraform apply -auto-approve -input=false
                  elif [ "$action" == "destroy" ]; then
                    terraform destroy -auto-approve -input=false
                  fi
              ) 2>&1 | stdbuf -oL sed "s|^|${color}${label} ${NC}|" # Adiciona Tag Visual

              # Retorna o exit code do pipeline (gra√ßas ao set -o pipefail)
              return $?
          }

          # ==============================================================================
          # MAIN: L√ìGICA PRINCIPAL
          # ==============================================================================
          
          # 1. Detec√ß√£o do Manifesto (Do seu c√≥digo antigo)
          echo "üîç Buscando manifest.json..."
          MANIFEST_PATH=$(git diff --name-only HEAD^ HEAD | grep "manifest.json" | head -n 1)
          if [ -z "$MANIFEST_PATH" ]; then
            MANIFEST_PATH=$(find . -name "manifest.json" -not -path "*/.*" | head -n 1)
          fi
          if [ -z "$MANIFEST_PATH" ]; then
            echo "‚ùå Erro: Nenhum manifest.json encontrado."
            exit 1
          fi
          echo "‚úÖ Manifesto carregado: $MANIFEST_PATH"

          # 2. Configura√ß√µes Globais
          ACTION=$(jq -r '.action // "apply"' "$MANIFEST_PATH") # Default apply se vazio
          BACKEND_ROLE=$(jq -r '.backend_global_config.role_arn' "$MANIFEST_PATH")
          BACKEND_REGION=$(jq -r '.backend_global_config.region' "$MANIFEST_PATH")

          echo "‚ö° A√ß√£o Global: $ACTION"
          echo "üîë Configurando Backend Profile ($BACKEND_ROLE)..."
          authenticate "$BACKEND_ROLE" "$BACKEND_REGION" "backend"

          # 3. Loop pelos Est√°gios
          TOTAL_STAGES=$(jq '.pipeline_stages | length' "$MANIFEST_PATH")

          for (( i=0; i<$TOTAL_STAGES; i++ )); do
              STAGE_NAME=$(jq -r ".pipeline_stages[$i].stage_name" "$MANIFEST_PATH")
              IS_PARALLEL=$(jq -r ".pipeline_stages[$i].parallel_execution" "$MANIFEST_PATH")
              STATES_JSON=$(jq -c ".pipeline_stages[$i].states[]" "$MANIFEST_PATH")

              echo "::group::üöÄ Est√°gio: $STAGE_NAME (Paralelo: $IS_PARALLEL)"

              pids=""
              failed=0

              while read -r state; do
                  path=$(echo "$state" | jq -r '.path')
                  provider=$(echo "$state" | jq -r '.provider')
                  target_auth=$(echo "$state" | jq -r '.target_auth')
                  
                  if [ ! -d "$path" ]; then
                       echo "‚ö†Ô∏è  Diret√≥rio $path n√£o existe. Pulando."
                       continue
                  fi

                  if [ "$IS_PARALLEL" == "true" ]; then
                      # Roda em background
                      run_terraform_process "$path" "$ACTION" "$target_auth" "$provider" &
                      pids="$pids $!"
                  else
                      # Roda sequencial
                      run_terraform_process "$path" "$ACTION" "$target_auth" "$provider"
                      if [ $? -ne 0 ]; then failed=1; break; fi
                  fi
              done <<< "$STATES_JSON"

              # Se paralelo, aguarda todos
              if [ "$IS_PARALLEL" == "true" ]; then
                  for pid in $pids; do
                      wait $pid
                      if [ $? -ne 0 ]; then failed=1; fi
                  done
              fi

              if [ $failed -ne 0 ]; then
                  echo "::error::Falha na execu√ß√£o do est√°gio $STAGE_NAME"
                  exit 1
              fi

              echo "::endgroup::"
          done

          echo "‚úÖ Pipeline finalizado com sucesso."
