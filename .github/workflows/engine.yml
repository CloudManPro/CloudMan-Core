# Arquivo: .github/workflows/engine.yml (no reposit√≥rio cloudman-core)
name: Dynamic GitOps Pipeline

on:
  # --- CORRE√á√ÉO PRINCIPAL: Permite ser chamado por outro reposit√≥rio ---
  workflow_call:
    inputs:
      aws_region:
        required: false
        type: string
        default: "us-east-1"
        description: "Regi√£o da AWS para deploy"
    secrets:
      AWS_ROLE_ARN:
        required: true
        description: "ARN da Role OIDC para assumir na conta do cliente"

  # Gatilhos para testes manuais ou push direto no repo Core (opcional)
  workflow_dispatch:
  push:
    paths:
      - '**/manifest.json'
      - '**/main.tf'

permissions:
  id-token: write   # Necess√°rio para autentica√ß√£o OIDC da AWS
  contents: read    # Necess√°rio para ler o c√≥digo (checkout)

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do C√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detectar Manifest e Configurar Pipeline
        id: flow
        shell: bash
        run: |
          echo "üîç Buscando manifest.json alterado..."
          
          # 1. Tenta achar no git diff (arquivo modificado no commit)
          MANIFEST_PATH=$(git diff --name-only HEAD^ HEAD | grep "manifest.json" | head -n 1)
          
          # 2. Se n√£o achou no diff, procura no diret√≥rio (fallback)
          if [ -z "$MANIFEST_PATH" ]; then
            MANIFEST_PATH=$(find . -name "manifest.json" -not -path "*/.*" | head -n 1 | sed 's|./||')
          fi

          if [ -z "$MANIFEST_PATH" ]; then
            echo "‚ùå Nenhum manifest.json encontrado."
            exit 1
          fi

          echo "‚úÖ Manifesto encontrado: $MANIFEST_PATH"

          # 3. Extrai a A√ß√£o (plan, apply, destroy)
          ACTION=$(jq -r '.action' "$MANIFEST_PATH")
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          
          # 4. Prepara a lista de States (Pastas)
          # Se for destroy, inverte a ordem para n√£o quebrar depend√™ncias.
          # Normaliza tudo para array de arrays para suportar paralelismo.
          if [ "$ACTION" == "destroy" ]; then
            STAGES_JSON=$(jq -c '.states | reverse | .[] | if type == "array" then . else [.] end' "$MANIFEST_PATH")
          else
            STAGES_JSON=$(jq -c '.states[] | if type == "array" then . else [.] end' "$MANIFEST_PATH")
          fi

          # 5. Salva em Base64 para passar para o pr√≥ximo step sem quebrar linhas
          echo "stages_list=$(echo "$STAGES_JSON" | base64 -w 0)" >> $GITHUB_OUTPUT

      - name: Configurar Credenciais AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Usa o segredo passado pelo cliente via workflow_call
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          # Usa o input passado pelo cliente (ou default us-east-1)
          aws-region: ${{ inputs.aws_region || 'us-east-1' }}

      - name: Configurar Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Executar Pipeline (Plan/Apply/Destroy)
        shell: bash
        run: |
          ACTION="${{ steps.flow.outputs.action }}"
          STAGES_B64="${{ steps.flow.outputs.stages_list }}"
          
          # Decodifica a lista de est√°gios
          STAGES=$(echo "$STAGES_B64" | base64 -d)

          echo "üöÄ Iniciando execu√ß√£o: Terraform $ACTION"

          # Loop linha a linha (cada linha √© um grupo de execu√ß√£o)
          while IFS= read -r group; do
            if [ -z "$group" ]; then continue; fi
            
            # Extrai os nomes das pastas dentro do grupo (JSON Array)
            items=$(echo "$group" | jq -r '.[]')
            
            echo "::group::üîÑ Processando Grupo: $items"
            
            pids=""
            for item in $items; do
              # Roda em subshell em background (&) para paralelismo dentro do grupo
              (
                echo "   üìÇ [$item] Inicializando..."
                
                # Init reconfigurando backend baseado na pasta
                terraform -chdir=$item init -backend-config="key=$item/terraform.tfstate" -reconfigure -input=false > /dev/null
                
                echo "   ‚ö° [$item] Executando $ACTION..."
                if [ "$ACTION" == "plan" ]; then
                   terraform -chdir=$item plan -input=false
                else
                   terraform -chdir=$item $ACTION -auto-approve -input=false
                fi
              ) &
              
              # Armazena o ID do processo para esperar depois
              pids="$pids $!"
            done

            # Espera todos os processos desse grupo terminarem antes de ir para o pr√≥ximo
            wait $pids
            echo "::endgroup::"
            
          done <<< "$STAGES"
          
          echo "‚úÖ Pipeline finalizado com sucesso."
