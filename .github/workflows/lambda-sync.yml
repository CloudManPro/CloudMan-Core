name: "CloudMan Engine: Lambda Sync"

on:
  # Permitir ser chamado por workflows de outros repositÃ³rios (Clientes)
  workflow_call:
    inputs:
      direction:
        type: string
        description: "push (AWS->Git) or pull (Git->AWS)"
        required: true
      region:
        type: string
        description: "Default AWS Region"
        default: "us-east-1"
      role_arn:
        type: string
        description: "IAM Role to Assume via OIDC"
        required: true
      resources_json:
        type: string
        description: "JSON Array of resources to sync"
        required: true

  # Permitir disparo manual direto (para testes internos)
  workflow_dispatch:
    inputs:
      direction:
        description: "push (AWS->Git) or pull (Git->AWS)"
        required: true
      region:
        description: "Default AWS Region"
        default: "us-east-1"
      role_arn:
        description: "IAM Role to Assume via OIDC"
        required: true
      resources_json:
        description: "JSON Array of resources to sync"
        required: true

permissions:
  id-token: write   # ObrigatÃ³rio para autenticaÃ§Ã£o OIDC AWS
  contents: write   # ObrigatÃ³rio para Push no Git (quando direction=push)

jobs:
  sync-engine:
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          # Garante que baixamos o cÃ³digo do repositÃ³rio onde o workflow estÃ¡ rodando (Cliente),
          # e nÃ£o o cÃ³digo do repositÃ³rio do Engine.
          repository: ${{ github.repository }}

      - name: ğŸ”‘ Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.role_arn }}
          aws-region: ${{ inputs.region }}
          role-session-name: CloudManSyncSession

      - name: âš¡ Process Resources (CloudMan Engine)
        id: processor
        uses: actions/github-script@v7
        env:
          INPUT_DIRECTION: ${{ inputs.direction }}
          INPUT_RESOURCES: ${{ inputs.resources_json }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            // 1. Parse Inputs
            const direction = process.env.INPUT_DIRECTION;
            let resources = [];
            
            try {
                resources = JSON.parse(process.env.INPUT_RESOURCES);
            } catch (e) {
                console.error("âŒ Failed to parse resources_json. Ensure it's a valid JSON string.");
                throw e;
            }

            console.log(`ğŸš€ Starting ${direction.toUpperCase()} for ${resources.length} resources...`);

            // Helper: Run Shell Command
            function run(cmd) {
              try {
                execSync(cmd, { stdio: 'inherit' }); // stdio: inherit mostra logs em tempo real
              } catch (e) {
                console.error(`âŒ Command failed: ${cmd}`);
                throw e;
              }
            }

            // 2. Main Processing Loop
            for (const res of resources) {
                // Support generic 'id' or specific 'function_arn'
                const funcId = res.function_arn || res.id; 
                const folder = res.folder_path || res.git_path;
                const provider = res.provider || 'aws'; // Default AWS
                const region = res.region || '${{ inputs.region }}';

                if (provider !== 'aws') {
                    console.warn(`âš ï¸ Provider '${provider}' not fully supported yet. Skipping ${funcId}.`);
                    continue;
                }

                console.log(`\n---------------------------------------------------`);
                console.log(`ğŸ“¦ Resource: ${funcId}`);
                console.log(`ğŸ“‚ Folder: ${folder}`);
                console.log(`ğŸŒ Region: ${region}`);

                if (direction === 'push') {
                    // --- PUSH (CLOUD -> GIT) ---
                    console.log('ğŸ”½ Downloading code from AWS...');
                    
                    // a) Get Code URL (AWS CLI)
                    const getUrlCmd = `aws lambda get-function --function-name "${funcId}" --query 'Code.Location' --output text --region ${region}`;
                    const url = execSync(getUrlCmd).toString().trim();

                    if (!url || url === 'None') {
                        throw new Error(`Could not get code URL for ${funcId}. Check if function exists.`);
                    }

                    // b) Download & Unzip safely
                    run(`mkdir -p temp_lambda_dl`);
                    run(`curl -sL "${url}" -o lambda_dl.zip`);
                    run(`unzip -o -q lambda_dl.zip -d temp_lambda_dl`);
                    
                    // c) Sync to Git Folder
                    run(`mkdir -p "${folder}"`);
                    // Rsync: archive mode, verbose, delete extra files locally, exclude .git
                    run(`rsync -av --delete --exclude '.git' temp_lambda_dl/ "${folder}/"`);
                    
                    // d) Cleanup
                    run(`rm -rf temp_lambda_dl lambda_dl.zip`);

                } else if (direction === 'pull') {
                    // --- PULL (GIT -> CLOUD) ---
                    console.log('ğŸ”¼ Uploading code to AWS...');
                    
                    if (!fs.existsSync(folder)) {
                         console.warn(`âš ï¸ Folder '${folder}' does not exist in repo. Skipping.`);
                         continue;
                    }

                    // a) Zip Folder Content
                    // -X: Keeps file attributes, -r: recursive
                    // Zipa o conteÃºdo da pasta, nÃ£o a pasta em si.
                    const zipName = `deploy_${Date.now()}.zip`;
                    run(`cd "${folder}" && zip -r -X -q "../../${zipName}" .`);

                    // b) Update Function Code
                    run(`aws lambda update-function-code --function-name "${funcId}" --zip-file fileb://${zipName} --region ${region} --publish`);

                    // c) Cleanup
                    run(`rm ${zipName}`);

                } else if (direction === 'create') {
                    // --- CREATE (BOILERPLATE) ---
                    console.log('âœ¨ Initializing boilerplate...');
                    
                    if (fs.existsSync(folder)) {
                        console.log(`Folder '${folder}' already exists. Skipping init.`);
                        continue;
                    }
                    
                    run(`mkdir -p "${folder}"`);
                    // Cria um index.js bÃ¡sico (Node.js) como exemplo
                    const boilerplate = `exports.handler = async (event) => {\n  return { statusCode: 200, body: 'Hello from CloudMan!' };\n};`;
                    fs.writeFileSync(path.join(folder, 'index.js'), boilerplate);
                    console.log(`Created index.js in ${folder}`);
                }
            }

      - name: ğŸ“ Commit Changes (Push/Create Only)
        if: inputs.direction == 'push' || inputs.direction == 'create'
        run: |
          git config user.name "CloudMan Bot"
          git config user.email "bot@cloudman.pro"
          
          git add .
          
          # Commit only if changes exist
          if git diff --staged --quiet; then
            echo "âœ… No changes to commit."
          else
            git commit -m "cloudman(sync): Sync code from Cloud [skip ci]"
            git push
            echo "âœ… Changes pushed successfully."
          fi
