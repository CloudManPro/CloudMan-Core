#.github/workflows/lambda-sync.yml
name: "CloudMan Engine: Lambda Sync"

on:
  # Permitir ser chamado por workflows de outros reposit√≥rios (Clientes)
  workflow_call:
    inputs:
      # 1. Par√¢metros de Opera√ß√£o
      direction:
        type: string
        description: "push (AWS->Git), pull (Git->AWS) or create"
        required: true
      region:
        type: string
        description: "Default AWS Region"
        default: "us-east-1"
      role_arn:
        type: string
        description: "IAM Role to Assume via OIDC"
        required: true
      resources_json:
        type: string
        description: "JSON Array of resources to sync"
        required: true

      # 2. Par√¢metros do Reposit√≥rio Alvo
      target_repo:
        type: string
        description: "Target Repository (Org/Repo)"
        required: true
      target_branch:
        type: string
        description: "Target Branch"
        default: "main"

      # 3. Autentica√ß√£o Automatizada (GitHub App)
      git_token:
        type: string
        description: "App Token passed from backend/listener"
        required: true

  # Permitir disparo manual direto (para testes internos)
  workflow_dispatch:
    inputs:
      direction:
        description: "push, pull or create"
        required: true
      region:
        default: "us-east-1"
      role_arn:
        required: true
      resources_json:
        required: true
      target_repo:
        required: true
      target_branch:
        default: "main"
      git_token:
        required: true

permissions:
  id-token: write   # Obrigat√≥rio para autentica√ß√£o OIDC AWS
  contents: write   # Obrigat√≥rio para opera√ß√µes Git

jobs:
  sync-engine:
    runs-on: ubuntu-latest
    steps:
      - name: üõ°Ô∏è Mask Token
        # Seguran√ßa: Garante que o token n√£o apare√ßa nos logs
        run: echo "::add-mask::${{ inputs.git_token }}"

      - name: üì• Checkout Target Repository
        uses: actions/checkout@v4
        with:
          # Baixa o reposit√≥rio definido no input (o do cliente)
          repository: ${{ inputs.target_repo }}
          ref: ${{ inputs.target_branch }}
          # Usa o token da App para ter permiss√£o de escrita
          token: ${{ inputs.git_token }}

      - name: üîë Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.role_arn }}
          aws-region: ${{ inputs.region }}
          role-session-name: CloudManSyncSession

      - name: ‚ö° Process Resources (Smart Engine)
        id: processor
        uses: actions/github-script@v7
        env:
          INPUT_DIRECTION: ${{ inputs.direction }}
          INPUT_RESOURCES: ${{ inputs.resources_json }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            // --- HELPER: DETEC√á√ÉO DE RUNTIME ---
            function getBoilerplate(runtime) {
                const r = (runtime || '').toLowerCase();

                // 1. Python
                if (r.includes('python')) {
                    return {
                        filename: 'lambda_function.py',
                        content: `import json\n\ndef lambda_handler(event, context):\n    # TODO: Implement your logic here\n    return {\n        'statusCode': 200,\n        'body': json.dumps('Hello from CloudMan (Python)!')\n    }`
                    };
                }
                // 2. Node.js
                if (r.includes('node') || r.includes('js')) {
                    return {
                        filename: 'index.js',
                        content: `exports.handler = async (event) => {\n    // TODO: Implement your logic here\n    const response = {\n        statusCode: 200,\n        body: JSON.stringify('Hello from CloudMan (Node.js)!'),\n    };\n    return response;\n};`
                    };
                }
                // 3. Java
                if (r.includes('java')) {
                    return {
                        filename: 'Handler.java',
                        content: `package example;\nimport com.amazonaws.services.lambda.runtime.Context;\nimport com.amazonaws.services.lambda.runtime.RequestHandler;\n\npublic class Handler implements RequestHandler<Object, String>{\n  @Override\n  public String handleRequest(Object input, Context context) {\n    return "Hello from CloudMan (Java)!";\n  }\n}`
                    };
                }
                // 4. Go
                if (r.includes('go')) {
                    return {
                        filename: 'main.go',
                        content: `package main\nimport (\n\t"github.com/aws/aws-lambda-go/lambda"\n)\nfunc HandleRequest() (string, error) {\n\treturn "Hello from CloudMan (Go)!", nil\n}\nfunc main() {\n\tlambda.Start(HandleRequest)\n}`
                    };
                }
                
                // Fallback (Node)
                return {
                    filename: 'index.js',
                    content: `exports.handler = async (event) => {\n  return { statusCode: 200, body: 'Hello from CloudMan (Default)!' };\n};`
                };
            }

            // --- HELPER: SHELL EXEC ---
            function run(cmd) {
              try {
                execSync(cmd, { stdio: 'inherit' }); 
              } catch (e) {
                console.error(`‚ùå Command failed: ${cmd}`);
                throw e;
              }
            }

            // --- MAIN LOGIC ---
            const direction = process.env.INPUT_DIRECTION;
            let resources = [];
            
            try {
                resources = JSON.parse(process.env.INPUT_RESOURCES);
            } catch (e) {
                console.error("‚ùå Failed to parse resources_json.");
                throw e;
            }

            console.log(`üöÄ Starting ${direction.toUpperCase()} for ${resources.length} resources...`);

            for (const res of resources) {
                const funcId = res.function_arn || res.id; 
                const folder = res.folder_path || res.git_path;
                const region = res.region || '${{ inputs.region }}';
                // Captura o runtime enviado pelo Front (ou vazio se n√£o tiver)
                const runtime = res.runtime || ''; 

                console.log(`\n---------------------------------------------------`);
                console.log(`üì¶ Resource: ${funcId}`);
                console.log(`üìÇ Folder: ${folder}`);
                console.log(`‚öôÔ∏è Runtime: ${runtime || 'Unknown (Using Default)'}`);

                // --- CREATE (INIT) ---
                if (direction === 'create') {
                    console.log('‚ú® Initializing boilerplate...');
                    
                    if (fs.existsSync(folder)) {
                        console.log(`Folder '${folder}' already exists. Skipping.`);
                        continue;
                    }
                    
                    run(`mkdir -p "${folder}"`);

                    // Gera o arquivo correto baseado no runtime
                    const template = getBoilerplate(runtime);
                    const filePath = path.join(folder, template.filename);
                    
                    fs.writeFileSync(filePath, template.content);
                    console.log(`‚úÖ Created ${template.filename}`);
                    
                    // Cria um README de metadados
                    fs.writeFileSync(path.join(folder, 'README.md'), `# ${funcId}\n\nRuntime: ${runtime}\nGenerated automatically by CloudMan.`);

                // --- PUSH (CLOUD -> GIT) ---
                } else if (direction === 'push') {
                    console.log('üîΩ Downloading code from AWS...');
                    
                    const getUrlCmd = `aws lambda get-function --function-name "${funcId}" --query 'Code.Location' --output text --region ${region}`;
                    const url = execSync(getUrlCmd).toString().trim();

                    if (!url || url === 'None') {
                        throw new Error(`Could not get code URL for ${funcId}. Check if function exists.`);
                    }

                    run(`mkdir -p temp_lambda_dl`);
                    run(`curl -sL "${url}" -o lambda_dl.zip`);
                    run(`unzip -o -q lambda_dl.zip -d temp_lambda_dl`);
                    run(`mkdir -p "${folder}"`);
                    run(`rsync -av --delete --exclude '.git' temp_lambda_dl/ "${folder}/"`);
                    run(`rm -rf temp_lambda_dl lambda_dl.zip`);

                // --- PULL (GIT -> CLOUD) ---
                } else if (direction === 'pull') {
                    console.log('üîº Uploading code to AWS...');
                    
                    if (!fs.existsSync(folder)) {
                         console.warn(`‚ö†Ô∏è Folder '${folder}' does not exist in repo. Skipping.`);
                         continue;
                    }

                    const zipName = `deploy_${Date.now()}.zip`;
                    run(`cd "${folder}" && zip -r -X -q "../../${zipName}" .`);
                    run(`aws lambda update-function-code --function-name "${funcId}" --zip-file fileb://${zipName} --region ${region} --publish`);
                    run(`rm ${zipName}`);
                }
            }

      - name: üìù Commit Changes (Push/Create Only)
        if: inputs.direction == 'push' || inputs.direction == 'create'
        run: |
          git config user.name "CloudMan Bot"
          git config user.email "bot@cloudman.pro"
          
          git add .
          
          if git diff --staged --quiet; then
            echo "‚úÖ No changes to commit."
          else
            git commit -m "cloudman(sync): Sync code from Cloud [skip ci]"
            # O push funciona gra√ßas ao 'token: inputs.git_token' no checkout
            git push
            echo "‚úÖ Changes pushed successfully."
          fi
            echo "‚úÖ Changes pushed successfully."
          fi
